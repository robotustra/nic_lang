[10.09.2015]

	Это руководство по языку nic.

	Язык nic является forth-подобным, объектно ориентированным языком, с несколько
иной трактовкой ООП.

	Объектами в nic считаются данные, а код который модифицирует данные, слова (или 
операторы) не являются свойствами объекта. Конечно же код может рассматриваться 
как данные, но для этого его нужно "оживить", или скомпилировать.

	Таким образом, объекты всегда пассивны, и их состояние может меняться кодом извне. 
Код же всегда активен и по разному может действовать на разные объекты.
По сути дела, каждое слово различает типы объектов перед выполнением.
Код является причиной, изменение данных является следствием. 

	Каждый объект имеет набор свойств (или полей данных). Воздействие на объект, или
смена его состояния осуществляется оператором (действием или словом), которое его
меняет.

	Программа на языке nic представляет последовательность слов-объектов, при этом
каждое последующее слово может модифицировать свойства или состояния предыдущих
объектов.

	Этот подход позволяет динамически строить объекты нового типа во время
выполнения, и также создавать новые операторы, которые будут работать с новыми
типами корректно.

	nic включает в себя набор базовых типов и операторов (слов), которые позволяют 
создавать новые объекты и слова. Все слова языка занимают так называемый 0(нулевой)
уровень или слой. 

	Если создается некое слово, то оно автоматически помещается в слой на 1 выше
уровня максимального уровня слов, используемых при его написании.
Например, если мы используем только слова 0 уровня, то заново скомпилированное слово 
будет располагаться на уровне 1. Если же мы используем новое слово с уровнем 1 для
написания еще одного слова, то оно будет помещено на уровень 2.
Это позволит проследить зависимости в коде и избежать создания ненужных операторов.

	Язык nic, в отличие от Forth, является типизированным. Это позволяет 
программисту быстрее находить ошибки при написании программы. Тем не менее, объекты
могут менять свой тип во время выполнения, если это необходимо программисту. Более
того, один и тот же объект может рассматриваться как совершенно другой тип, или 
отображаться друг на друга. Поэтому типизация в языке слабая, ответственность за
правильность использования типов ложится на программиста.

	Кроме операторов и базовых типов язык использует концепцию стека, в которую
помещаются все объекты (или указатели на них), над которыми производятся все 
операции. Размер стека может быть расширен (изменен) во время выполнения.
Так же имеется дополнительный стек для операций типа flip/flop, которые позволяют
снять часть объектов с вершины основного стека и переместить его в другой стек 
(аналог закладки в книге).

	Одна ячейка стека имеет размер, равный размеру указателя в системе (void*) и 
компьютеров  обычно равна 4 байтам. Все типы, которые имеют размер меньше либо
равный размеру указателя помещаются непосредственно в стек, а для тех, которые 
больше - помещаются в динамически выделяемую память, а указатель на объект 
помещается в стек. Таким образом, большие объекты используют динамически выделяемую
память.

	Синтаксис слов nic не чувствителен к регистру, поэтому имена операторов можно
писать в любом регистре. Это позволяет использовать регистр для более удобного 
чтения кода и акцентирования внимания где это необходимо. Однако новые слова и переменные
добавляемые в систему чувствительны к регистру, и эту возможность можно использовать
для различения переменных и слов.

	Типы которые помещаются в стек это BYTE и INT.
Размер BYTE - 1 байт, и он является знаковым. INT занимает 4 байта, и является
аналогом типа long в Си.

	Все остальные базовые типы не помещаются в ячейку стека и используют динамически
выделяемую память (или специальный стек).
Это такие типы как
	DUBL - имеет размер 8 байт, аналог double в Си.
	STRI - строка, эквивалентна массиву BYTE. 
	TEXT - это упорядоченный линейный массив любых переменных (обычно строк).

	В языке nic используется концепция переменных, то есть в стек можно поместить
как значение, так и указатель на переменную. При этом, ячейка будет иметь разные типы,
в первом случае "значение", а во втором "указатель на переменную". Хотя 
тип числа, находящегося в ячейке стека можно преобразовать в любое значение.
В этом смысле - тип значения ячейки подсказывает интерпретатору как работать с объектом.

	Для переменных типа DUBL используется отдельный стек переменных, который не 
используется в вычислениях напрямую. Все обращения со значениями типа DUBL 
проводятся невидимо для программиста.

	В момент создания объекты являются пассивными (просто текст программы), то для 
получения "выполнимого" слова его нужно скомпилировать и/или загрузить с носителя.

	Обычный способ создания программ на nic является написание кода прямо в 
интерпретаторе, который поддерживает несколько режимов работы. По сути дела 
интерпретатор представляет собой оболочку, позволяющую создавать и выполнять 
программы. Так же оболочка поддерживает концепцию входных и выходых устройств, с
которыми могут взаимодействовать выполняемые программы.

	Основные моды оболочки nic:

	nic(i)> - interpreter mode
Режим интерпретации - интерпретирует вводимую строку и позволяет отображать
состояние всех объектов в системе, и используется для пошаговой отладка выполняемого кода
или написания программы.
Данный режим позволяет сохранить всю последовательность введенных команд в файл.
Если нужно очистить буфер вводимых команд, или сделать частичную корректировку - 
оболочка может перейти в режим редактора. 
По умолчанию весь введенный текст сохраняется в переменную типа TEXT input
и представляет собой односвязный набор строк.

	nic(e)> - editor
	При переходе в режим редактирования любая строка или текст может быть выведен на 
экран, отредактирован и сохранен обратно в объект. После изменений объектов, болочка 
переходит в режим интерпретатора.

	После того, как мы создали какой либо символ (слова, программу) или данные в
памяти, мы можем запустить ее на выполнение запустив команду RUN с параметрами или 
без.
	nic(r)> - run

	В этом случае оболочка переходит в режим выполнения задачи и может 
взаимодействовать со всеми доступными устройствами в системе.
Выполнение программы можно прервать, или приостановить, вводя определенную 
комбинацию с клавиатуры.

	nic(w)> - wait
	При этом, производится переход интерпретатора с состояние wait. Из этого 
состояния можно либо продолжить выполнение приостановленной задачи, либо выйти в 
режим интерпретатора, прервав выполнение.

	Кроме каналов ввода-вывода у оболочки есть специальные устройства, которые 
называются TOP и BOT(tom), предназначенные для организации иерархической системы 
оболочек. Это встроенный механизм IPC, поскольку каждая оболочка представляет собой
автономный процесс.

	Если программа запускает какой-то автономный поток на выполнение (новую 
виртуальную  машину), то у этой виртуальной машины будет свой стек и свое 
пространство, не связанное с текущей оболочкой.

	Вся связь осуществляется через каналы TOP, BOT, причем все зависимые от данной оболочки
будут получать информацию из TOP, а текущая оболочка будет отправлять данные в BOT.
Если количество порожденных процессов будет несколько, то отправка данных все равно будет 
передаваться для всех процессов через один канал, а далее порожденные процессы будут уже 
решать какая информация принадлежит им.

	Обратная связь будет осуществляться через канал TOP, то есть подчиненные процессы каждый
имеет свой буфер TOP, но управляющий процесс будет иметь один интерфейс для чтения данных со 
всех TOP каналов подчиненных процессов. Информация о том какой процесс передал данные зависит
от конкретной реализации процесса.

	В некоторых случаях текущий процесс может пытаться подключить свой TOP канал 
(это можно задать параметрами при старте) к некому другому процессу в системе, который слушает
свой BOT канал, с тем чтобы стать ведомым процессом. Если системе это удалось, то она может 
обмениваться данными с суперпроцессом.

	Любая оболочка может иметь ноль или несколько субпроцессов и один или ноль суперпроцессов.

	Если не подключен никакой суб или супер процесс то отправка данных в каналы TOP и BOT не
оказывает никакого влияния.

	Любой суперпроцесс может послать команду подчиненному процессу на завершение, при этом
подчиненный процесс обязан передать эту команду далее вниз всем субпроцессам и дождаться 
от них ответа. Если субпроцесс не отвечает на команду то он выгружается текущим процессом, 
то есть уничтожаются его стек и закрываются все ресурсы процесса.
В нектором смысле шелл, из которого запущей экземпляр nic, является суперпроцессом для него,
так как из него можно посылать управляющие команды, меняющие моду выполнения (состояние 
виртуальной машины интерпретатора), а не только данные или код.

	Оболочка имеет так же общий пул для данных одного ранга. То есть две одноранговые 
оболочки, могут посылать друг другу данные горизонтально. 
Для этого существуют спецустройства GIVE (давать) TAKE (принимать)

	GIVE отсылает данные в общий пул, который могут считать другие процессы командой TAKE.
Этот буфер не бесконечный, и если никто не читает сообщения, то они пропадут, так как каждый
канал имеет ограниченный буфер, если он не расширен специально.

	GIVE и TAKE могут быть блокирующими, то есть если процесс послал сообщение и его никто 
не считал, то в случае блокировки по выходу процесс приостанавливается. Если же посылка
не блокирующая, то отправляющий процесс может проверить состояние буфера отправки, был ли он считан другими процессами.

	Через TAKE процесс может получать информацию о наличии доступных данных от других
процессов. Надо заметить, что само чтение данных из буфера не сбрасывает данные с 
отправляющего буфера, а только помечает их как прочитанные.

	Процесс может сам прочитать свои же данные, из отправленного буфера при необходимости.

Надо заметить, что все взаимодействие между процессами осуществляется асинхронно, и задается
операционной системой. Каждый процесс изолирован относительно другого.

	Связь с другими устройствами типа DISK, NETW, UART, осуществляется посредством 
оболочки и ОС. Устройства могут быть сконфигурированы так как имеют зависимые параметры 
средствами языка.

	С точки зрения оболочки они представляют собой обычные объекты данных с именоваными 
полями, которые можно изменять. Какие поля имеют устройства и как их изменять будет описано
в соответсвтующей главе ниже.

	
				Режим Интепретации. Синтаксис команд.
				-------------------------------------

Как было сказано выше, оболочка для интерпретатора nic стартует в режиме интепретатора, о чем можно судить по подсказке (i).

nic(i)> 

В интепретаторе можно создавать объекты любой сложности, компилировать и выполнять их.
Ввод осуществляется обычным способом, как в терминале, и заканчивается клавишей <Enter>.

После этого введенная строка сохранятеся в истории введенных команд и только после этого интерпретируется. Надо заметить, что если введенная команда не верная она все равно сохраняется в истории. История является последовательной и начинается только с момента запуска оболочки. При выходе из оболочки история автоматически сохраняется для бакапа.

В оболочку могут быть введены числа, символы или строки, определенные слова.

Значения, например такие как целые числа сохраняются прямо в стеке. Размер стека по умолчанию
64 ячейки, или 256 байт (каждая ячейка в памяти занимает 4 байта). 
Например, если мы введем

nic(i)> 12 34 56

то в стеке будет занято 3 ячейки, в самой первой будет лежать значение 12, во второй 34, в третей 56.
Далее над числами можно выполнять любые операции определенные в системе, например, сложение 
(ADD)

nic(i)>ADD

Оператор ADD принимает 2 аргумента на вход и производит сложение с двух чисел, расположенных на вершине стека, удаляет их и помещает результат обратно в стек. Таким образом после этой команды в стеке должны остаться 2 числа - 12 в первой ячейке и 90 во второй ячейке.

Чтобы увидеть содержимое стека надо набрать слово SHOW. (Надо заметить что набирать можно в любом регистре).

nic(i)>SHOW

Результат будет таким:

---stack top---
90 : INT
12 : INT
---stack bottom---
---stack2 top---
---stack2 bottom---

Как можно увидеть мы имеет 2 стека, один stack и вротой stack2. Наличие второго стека это новая концепция по сравнению с обычным Forth системой, рассмотрим ее позже.

	Мы видим что в стеке содержатся 2 целых числа, оболочка определила их как целые числа.
Слово SHOW является хорошим средством при отладке программ с тем чтобы выполнять программы
по шагам. SHOW не изменяет ни состояния стека ни оболочки.

Введем два слова сразу

nic(i)>ADD SHOW

Результат:

---stack top---
102 : INT
---stack bottom---
---stack2 top---
---stack2 bottom---

Мы видим, что произошло сложение 12 и 90, и результат сложения остался на вершине стека.

Если же нам нужно вывести результат вычисления на печать (stdout), то для этого используется
команда PRI. Она выводит значение величины на терминал и удаляет ее с вершины стека.
В результате у нас остался пустой стек. Это можно проверить командой SHOW.

При попытке выполнить команду PRI еще раз появится сообщение

Warning: Nothing to print

Которое означает, что стек пустой и в нем недостаточно аргументов.

Если нужно вывести бОльшее число аргументов из стека на печать нужно использовать команду
PRIN. Этой команде (==слову, ==функции) необходимо задать число ячеек стека, которые нужно
выыести на печать.

Введем какие-нибудь числа в стек.

nic(i)>24 54 34 -39 show

Получим:
---stack top---
-39 : INT
34 : INT
54 : INT
29 : INT
---stack bottom---
---stack2 top---
---stack2 bottom---

Теперь введем:
nic(i)> 3 PRIN

Результат:
-39 34 54

	Как мы видим, в результате напечаталось 3 числа. При этом сначала число 3 было помещено в 
тот же самый стек как параметр, потом команда PRIN взяла это число с вершины стека, потом проверила его на допустимые пределы (оно должно быть не отрицательным) и после этого напечатала 3 ячейки из стека и удалила значения из стека.

	Сейчас следует уяснить, что в nic, как и в Forth аргументы следуют перед вызовом
оператора и при этом они помещаются в стек. В отличие от Forth аргументы имеют тип и перед
вызовом оператора производится проверка типов аргументов.
	Что касается типов аргументов и как можно их изменять в процессе выполнения - 
описывается в последующих главах.

	Можно поэкспериментировать с этой командой и убедится, что всякий раз когда вводятся 
недопустимые значения для параметра команды PRIN она выдает предупреждение и оставляет стэк
в том же состоянии что и прежде.
Это отличает nic от Forth потому, что все слова (операторы) уровня 0 (вкомпилированные в оболочку) делают всевозможные проверки аргументов перед выполнением слова с тем чтобы не обрушить виртуальную машину. По сути дела, любые слова, любого другого уровня, построенные
на словах уровня 0 так же будут безопасны для виртуальной машины.

	В режиме выполнения (nic(r)>) эти предупреждения могут приостанавливать или отменять 
выполнение задач.
	То есть слово может быть выполнено без ошибок или предупреждений, то это означает,
что состояние стека и виртуальной машины предсказуемо, если же в процессе выполнения возникло
предупреждение, то это означает, что данные могли быть изменены, но это может никак не повлиять на дальшейшее выполнение следующих операторов.
Если же данные стека были изменены и это может повлиять на результаты выполнения целой программы то выполнение прерывается с выводом места ошибки.

	После этого можно модифицировать код и/или очистить стек и начать выполнение заново.

				Примеры основных команд
				-----------------------

Рассмотрим некоторые команды, которые следует хорошо освоить прежде чем переходить к более сложным вещам.

Введем слово LIST в интерпретатор.
nic(i)>LIST

Мы получим нечто вроде этого:
ADDR    SIZE    SHOW    DROP    DUP     ADD     SUB     LIST    SWAP    ROT     TYPE    PRI
PRIN    BYTE    INT     DUBL    NEGA    VALU    EQUL    VARL    VAR     SPEL    STRI    DEL
WORD    IS      FLIP    FLOP    DEEP    MUL     COMP    TRAN    DIM     IDX     MAP     UMAP
ARRA    WLIS    EXIT

Это не полный список слов в системе, но сейчас мы рассмотрим только основные из них.

Как видно, все слова состоят только из букв и этой стратегии следует придерживаться
при создании новых слов. При создании слов других уровней можно использовать больше чем 4 
буквы, но лучше стараться использовать как можно меньшее количество букв (максимум 6).
Максимальная длина имени составляет 32 символа, но и ее я считаю забольшой.
Удобно использовать буквосочетания типа (С - согласная, Г - гласная)
СГ, ГС, ССГ, СГС, СГСГ ССГС, СГСС, ГСГС, ГССГ и так далее, чтобы в слове присутствовала
хотя бы одна гласная, а согласные образовывали бы легкопроизносимый дифонг. 
Используя это правило легко создать большое число осмысленных слов, используя корни английских
и русских слов.

Знаки типа +, -, <, >, #, $ и так далее желательно не использовать, а так же цифры присоединенные
к имени, так как они захламляют имя. Так как в Forth имя может быть переопределено, при этом
старое слово не удаляется из кода, а становится недоступным, поскольку маскируется новым.
После удаления слова, если оно было определено более одного раза, становится доступным его 
предыдущее определение.

Мы уже знакомы со словами SHOW, ADD, PRI, PRIN, LIST.

Слово DROP имеет тот же смысл что и в Forth, только он убирает со стека не 1 параметр, а столько сколько 
задано. Например

nic(i)> 2 3 4 5 6 7
nic(i)> 2 DROP SHOW
---stack top---
5 : INT
4 : INT
3 : INT
2 : INT
---stack bottom---
---stack2 top---
---stack2 bottom---

Если задать целое число, большее чем число элементов в стеке, то DROP удалит все элементы в стеке,
и после этого выдаст предупреждение. Данное предупреждение не является критическим,
Поэтому DROP c большим числом аргументов может использоваться для обнуления стека.

SUB - вычитание. требует 2 параметра.
Отнимает от предыдущего элемента в стеке последний.
Аргументами могут являться целые и вещественные числа.
Эквивалентное действие можно получить если сделать NEGA ADD


a b SWAP -> b a
меняет a и b в стеке. При недостаче параметров ничего не делает. 

a b c ROT -> c a b


a TYPE -> a T
Помещает индекс типа элемента a на вершину стека. Нужно при создании переменных
такого же типа.

BYTE -> T
Помещает индекс типа BYTE на вершину стека. Нужно для создания переменной.

Вообще, чтобы создать простую переменную некого типа в nic нужно использовать слово VAR.
Синтаксис создания переменной такой

<имя переменной> <тип> VAR
Мы уже знаем, <тип> это ни что иное как индекс типа в ячейке стека. Задать его можно либо используя
слово TYPE, но при этом значение должно быть того типа что нам нужно,
или можно использовать слова
BYTE 
DUBL
INT

После помещения типа в стек задается имя переменной. Это может быть любая строка, начинающаяся с букв
и содержащая цифры или знаки подчеркивания. Максимальная длина имент переменных также 32 байта.

Имена переменных являются чувствительными к регистру! То есть переменные a и A - это 2 разные
переменные.

Например, создадим переменную a1:
nic(i)> a1 BYTE VAR
nic(i)> show
---stack top---
a1@0x606a20 : VARIABLE POINTER TO BYTE
---stack bottom---
---stack2 top---
---stack2 bottom---

Видно, что в стеке находится сама переменная, при этому указатель показывает на место где находится
сама структура переменной. В этой структуре хранится не только значение, но и тип переменной.

Заметим что после создания переменной - указатель на нее остается в стеке, но само значение переменной
не определено. Поэтому можно присвоить какое-либо значение этой переменной.

Например, присвоим этой переменной значение 40.

Если мы просто помести 40 в стек, то значение будет находится выше адреса переменной, но для присвоения
значения нужно чтобы порядок аргументов был обратный,
Делаем:
nic(i)> 40 SWAP
nic(i)> show
---stack top---
a1@0x606a20 : VARIABLE POINTER TO BYTE
40 : INT
---stack bottom---
---stack2 top---
---stack2 bottom---
nic(i)> EQUL
nic(i)> show
---stack top---
a1@0x606a20 : VARIABLE POINTER TO INT
---stack bottom---
---stack2 top---
---stack2 bottom---

Надо отметить, что при присвоении переменной бОльшего типа тип переменной так же меняется.
Возможно это будет устранено в будущем при более строгой типизации, но для простых типов
это не мешает. 
Нужно только помнить что тип переменной может изменится при присвоении переменной некоторого значения.
Вроде бы ничего не изменилось но теперь переменная a1 имеет значение 40.

Прежде чем мы это проверим попробуем удалить переменную из стека:
nic(i)> 1 DROP SHOW
---stack top---
---stack bottom---
---stack2 top---
---stack2 bottom---
Однако переменная не удалена из оболочки, она все еще существует, и увидеть ее можно с помощью команды
VARL (variable list)

nic(i)> VARL
---- Variables Stack Top ----
a1@606a58 : INT
---- Variables Stack Bot ----

Для того, чтобы дальше работать с переменной для этого нужно просто ввести имя переменной опять
nic(i)> a1
nic(i)> show
---stack top---
a1@0x606a20 : VARIABLE POINTER TO INT
---stack bottom---
---stack2 top---
---stack2 bottom---

Для того, чтобы получить значение переменной в стеке нужно использовать слово VALU

nic(i)> VALU
VALU keyword
nic(i)> show
---stack top---
40 : INT
---stack bottom---
---stack2 top---
---stack2 bottom---

Видим, что указатель переменной замещается значением переменной. 

Количество операторов в строке может быть произвольным и он ограничен только длиной входного буффера.
Но для удобства чтения лучше разбивать длинную строку на логические шаги.

Например строка

nic(i)> 3 4 5 ADD SWAP SUB SHOW
будет иметь тот же эффект что и 

nic(i)> 3 4 
nic(i)> 5 ADD 
nic(i)> SWAP SUB SHOW

Операции сложения не действуют на переменные, их можно использовать только для значений, находящихся в стеке.

Операции SWAP, DUP, DROP, ROT, применимы к любым аргументам, как простым значениям, так и указателям на переменные.

Слово SPEL(*пока не работает*) выводит на печать содержимое верхней ячейки стека без удаления самого значения из стека,
при этом, оно работает не только для простых значений но и для сложных объектов.

Для задания строки нужно следующая конструкция:

"string, may be with spaces" <имя строки> STRI

Например:

nic(i)> "test string" st1 STRI
Создаст строку st1 со значением "test string".

Заметим, что создать переменную без типа или в случае строки без задания значения невозможно.
Существует ряд слов для работы со строками, которые в большинстве своем применимы и для режима редактора,
которые рассмотрим чуть ниже.

Язык nic поддерживает концепцию вспомогательного стека, который иногда бывает необходим, если нужно
добраться до глубоко лежащих в стеке параметров.
При этом операция FLIP снимает заданное число параметров с вершины основного стека и помещает их в обратном порядке
в stack2. Далее после окончания операций над параметрами основного стека можно вернуть полностью или частично параметры
из дополнительного стека в основной операцией FLOP.

nic(i)> 23 45 67 89 -30 -40
nic(i)> 3 FLIP
nic(i)> show
---stack top---
67 : INT
45 : INT
23 : INT
---stack bottom---
---stack2 top---
89 : INT
-30 : INT
-40 : INT
---stack2 bottom---
nic(i)> ADD
nic(i)> 3 flop
nic(i)> show
---stack top---
-40 : INT
-30 : INT
89 : INT
112 : INT
23 : INT
---stack bottom---
---stack2 top---
---stack2 bottom---

FLIP/FLOP работает для любого типа элементов.

Немного слов про вещественные числа.
Так как вещественные числа не помещаются в стек - то для них создается специальный стек, который используется только
для их хранения.

При этом в основном стеке они выглядят как обычные числа типа DOUBLE.
nic(i)> 2.345
nic(i)> show
---stack top---
2.345000 : DOUBLE
---stack bottom---
---stack2 top---
---stack2 bottom---

Если удалить вещественное число из стека, то оно удаляется полностью, из основного и из специального стека.
Например операция "1 DROP" удалит вещественное значение из оболочки совсем.

Работа с вещественным стеком скрыта реализацией интерпретатора с целью однородной работы с числами.


				Операции со строками. Текст.
				----------------------------

Создать строку в стеке можно просто задав произвольную строку в двойных кавычках.

nic(i)> "the test string"

при этом в стеке создается безымянный объект, строка, которая не присвоена никакой переменной.

nic(i)> "the test string"
String param: 'the test string'
Allocated Var struct
Hash: 1868357362116043645
nic(i)> show
---stack top---
string1868357362116043645@0xa8f750 : STRING
---stack bottom---
---stack2 top---
---stack2 bottom---

Как видно временное имя строки состоит из слова "string" с добавленным к нему хэшем.
Это имя не является именем строки, в этом можно убедится используя слово VARL.

Более того, мы можем еще раз ввести такую же строку, при этом новая строка будет выделена в памяти по другому
адресу, хотя хэш ее будет такой же.

Присвоить строку переменной можно 2 способами, первый способ с помощью STRI был описан выше,
А второй способ:

nic(i)> "test string"
nic(i)> TYPE str1 SWAP VAR EQUL

Таким образом, мы стандартным способом можно создать переменную любого типа, определенного в системе
и потом может присвоить любое значение к этой переменной с помощью EQUL.
(*пока не работает*)

Слово VALU так же создает копию содержимого в стеке, с именем string<hash>.

SPEL просто выводит содержимое объекта на печать без удаления из стека.

Над строками можно выполнять стандартные операции:

s n HEAD -> s1
отрезание n символов от головы строки и помещение в стек. Создается неименованная строка.

s n TAIL -> s1
отрезание n символов с конца строки и помещение его в стек. Создается новая строка.

s1 s2 GLUE -> s3
склеивание двух строк с образованием новой неименованной строки.

s1 s2 FIND -> n
нахождение одной подстроки в другой. В стек помещается смещение. Если подстрока не найдена
n = -1

s1 s2 REPL -> s3
замена одной строки другой.

s1 n1 n2 CUT -> s2 
вырезание куска строки начиная со смещения n1 длиной n2

s1 s2 n INS -> s3
вставка строки в нужной позиции со смещением n. 
Новая строка помещается в стек.

s1 n1 n2 COPY -> s1 s2
вырезать фрагмент из строки начиная со смещения n1 длиной n2 и поместить в стек.


Работа со строками необходима не только во время выполнения программы, но так же
для создания новых слов.

				Создание новых слов
				-------------------

	Язык nic как и Forth позволяет создавать новые слова, на базе уже созданных слов.
Для этого используется слово TEXT и WORD.

TEXT представляет собой объект, включающий в себя односвязный список строк. Длина строк
может быть произвольной.
Создать текст можно следующим образом

s1 s2 s3 ... sn n <name> TEXT PACK - > tx

Строки s1 - sn могут быть безымянные, так и именованные, или это могут быть также переменные
типа текст, тогда они целиком добавятся в новую переменную.

<name> TEXT - создает переменную типа текст в пямяти, а PACK - добавляет последовательно
строки или тескты в новую переменную текст.

Еще один способ создания текста заключается в использовании примитивного встроенного редактора
если перевести оболочку из режима интерпретации в режим edit

nic(i)> EDIT
nic(e)> <первая введенная строка>
nic(e)> <вторая введенная строка>
...
nic(e)> <последняя введенная строка>
nic(e)> END
nic(i)>

После такой процедуры создается безымянный объект типа TEXT в стеке. При таком вводе невозможно
вернутся и отредактировать строку во время ввода. Однако это можно сделать потом.
Слово END заканчивает ввод текста и переводит оболочку в режим интерпретации.

Если вдруг внутри текста нужно ввести слово END в начале строки, то для этого нужно
использовать эскейп последовательность /END, в таком случае выход из режима редактирования
не произойдет. Последняя строчка END также не будет добавлена к тексту.

После создания безымянного текста в памяти можно использовать обычную процедуру создания 
именованной переменной, например

tx <textname> EQUL

Слово TYPE помещает индекс типа текст в стек, VAR создает переменную типа текст, а EQUL присваивает
значение типа текст переменной.

В общем случае текст может содержать что угодно, в том числе и тело какого-нибудь нового
слова. Но данный код может быть, например, запущен на интерпретацию или скомпилирован.

Рассмотрим специальный случай создания текста, который лучше всего использовать для создания новых
слов.
Используем слово WORD:

nic(i)> t1 t2 ... tn n <name> WORD
nic(e)> <первая строка кода>
nic(e)> <вторая строка кода>
nic(e)> ...
nic(e)> <последняя строка кода>
nic(e)> IS
nic(i)> 

t1 - tn - это индексы типов входных параметров, которые будет проверять слово, перед тем,
как перейти к выполнению кода. Если же объекты в стеке имеют не такую последовательность,
то слово выдаст ошибку и прервет свое выполнение. Количество типов может быть равно 0, тогда число 
n будет равно 0.

n - это число параметров, необходимое в стеке для запуска слова.
Если необходимо создать слово с переменным числом аргументов, то n должно быть равно -1.
При этом один или несколько типов могут предшествовать -1.

<name> - имя нового слова. Оно может быть уже определено в системе. Если существует подобное
имя но с другим числом и типом параметров, то такие слова будут доступны для использования
и интерпретатор будет выбирать нужный прототип слова для выполнения.
Если же сигнатура слова будет такой же как уже существующее слово - то предыдущее слово будет
экранироваться, пока новое слово не будет удалено из системы.

Завершается ввод словом IS. Если же потребуется ввести слово IS внутри кода, то нужно использовать
эскейп последовательность - /IS. При этом при сохранении строки в текст / символ удаляется.

Таким образом, мы может создавать слова, но они пока существуют в форме текста.
Слово в форме текста можно запустить на интерпретацию используя слово RUN

nic(i)> w RUN  
nic(r)> ....
nic(r)> ....
nic(i)>

Оболочка по очереди извлекает строки из слова, и выполняет их в интерпретаторе, и если
необходимо, может переходить в режим wait (nic(w)>) если требуется ввод данных с клавиатуры
или произошла нефатальная ошибка выполнения, например несоответствие типов в стеке или
неправильное число аргументов.

При этом выполнение интерпретации можно прервать если ввести STOP
По завершении интерпретации и при отсутствии ошибок выполнения оболочка возвращается в режим
интерпретации.

Если слово имеет некоторые ошибки или требуется изменить некоторые строки кода в уже существующем
коде, то можно использовать операции со строками.

Для того чтобы отобразить содержимое строк кода можно использовать слово 

SPEL - это слово позволяет вывести на экран содержимое всех строк по очереди.
Для того, чтобы легко можно был узнать номер строки в тексте можно использовать команду NLIN

Синтаксис будет таким:

w NLIN SPEL
Слово NLIN включает нумерацию строк текста для вывода объекта, но делает это только 1 раз перед
выводом. По сути дела это слово для управление форматом вывода, более подробно форматы вывода 
рассмотрим позже.

Для частичного вывода SPEL можно использовать модификатор SNIP

w NLIN SPEL n1 n2 SNIP

SNIP (snippet) - n1, n2 это начальные и конечные строки для вывода текста операцией SPEL.
обычно n1 меньше n2, но если n2 равно нулю или меньше n1, то выводится кусок текста от строки 
n1 включительно до конца текста. 

Таким образом, после выполнения этой команды мы увидим нумерованные строки и может узнать какую строку
можно заменить. 
Как мы помним, SPEL не удаляет объект из стека, поэтому слово все еще находится там.

Операции над строками могут быть следующими:

w n LDEL -> w'
Удаление строки номер n из текста.

w s n LINS -> w'
Вставка строки s в текст w после строки n.

w s n LREP -> w' 
Замена строки под номером n в тексте w на строку s.

Возможны и другие операции с текстом и модификация их. Данные операции не очень удобны с точки зрения
редактирования текста, однако они имеют необходимый и достаточный набор операций для
работы с текстом.

			
				Компиляция слов
				---------------

	После создания слова в текстовом виде, его можно скомпилировать в бинарную форму и вызывать
в виде функции, так же как и встроенные в оболочку слова уровня 0.
Как я уже было сказано раньше, уровень скомпилированного слова будет на 1 больше чем уровень
любого используемого слова. Таким образом, если мы при написании своего слова использовали
только базовые слова уровня 0, то наше новое слово будет являтся словом уровня 1.

например слово для расчета дистанции между двумя точками на плоскости будет выглядеть так:

DUBL DUBL DUBL DUBL 4 distan WORD 		// слово должно иметь типы double для X1, Y1, X2, Y2
1 FLIP SWAP								
1 FLIP 									// в стеке остались только X1 и X2, во втором стеке Y1 и Y2
SUB 									// X1-X2
DUP										// создаем еще одну копию в стеке
MUL										// (X1-X2)^2
2 FLOP 									// возвращаем Y1 и Y2 в основной стек
SUB DUP MUL 							// делаем то же что и с иксами
ADD SQRT 								// складываем, извлекаем корень квадратный
IS 										// конец слова.

таким образом слово distan будет прверять чтобы в стеке было 4 вещественных числа,
использует слова 0 уровня и будет являтся словом 1 уровня.

Как видно из листинга // используется для добавления коментария к строке и компилятор игнорирует 
комментарии. Многострочные комментарии используют такой же синтаксис как и в Си - /* */

Для компиляци слова надо воспользоваться словом COMP

w COMP ->
Если при компиляции слова w не произошло ошибок и все имена используемых слов существуют в системе,
то создается и загружается код нового слова.
Новое слово становится доступным с помощью команды LIST.

Теперь можно запустить это слово:

nic(i)> 0.0 0.0 1.0 -1.0 distan RUN

При этом интерпретатор будет выполнять следующие действия. Оболочка находит слово distan
в текстовом виде и обнаруживает, что оно было скомпилировано. Если есть метка о том,
что текст не модифицировался, то используется скомпилированная функция с параметрами,
загруженными из стека, и после выполнения значение помещается обратно в стек.

Если же текст слова был изменен с момента последней компиляции, то слово используется
в режиме интерпретации, а скомпилированный код не выполняется.

Для того, чтобы вернутся к скомпилированной версии нужно опять выполнить компиляцию
слова w COMP.

Как я уже упоминал ранее, с момента запуска интерпретатора каждая введенная строка сохраняется
в виде текста в переменную с именем ilog (interpterer log) и ее можно загрузить в стек и
использовать части лога для создания фрагментов кода, сохранения их в виде слов и т.д.
ilog ведет себя точно так же как любая текстовая переменная.

Для того чтобы извлечь часть строк из текста нужно использовать слово SNIP с созданием 
новой текстовой переменной, например так

ilog n1 n2 SNIP nt TEXT VAR EQUL

n1 n2 SNIP вырезает фрагмент строк из текста и создает временный фрагмент текста, далее
создаем переменную с именем nt и присваиваем ей этот временный фрагмент.

Дальше с полученным фрагментом можно сделать любые операции.


				Массивы, структуры, новые типы
				------------------------------

	Обычно, для программирования недостаточно иметь одиночные переменные и несколько
предопределенных типов. Любой современный язык программирования позволяет создавать новые
типы данных и/или сложные структуры данных. Язык nic тоже не является исключением.

Для того, чтобы определить новый тип нужно воспользоватьс словом создания типа NEWT (new type)

новый тип конструирутеся следующим образом:

t1 ... tn n <name> NEWT

t1 - tn - это индексы уже определенных типов, помещенные в стек, n - это число ячеек
вниз, которые содержат индекс типа, 

<name> - имя нового типа.

После выполнения такой операции имя нового типа можно использовать вместе со словом VAR
Которое будет создавать переменную данного типа и правильно распределять память при 
конструировании объекта. Оператор EQUL также будет правильно выполнять присваивание 
данных, а VALU будет правильно разворачивать значения в стеке.

Надо заметить, что при декларации новых типов можно использовать уже определенные новые типы
это онзачает, что новый объект будт иметь уровен инкапсуляции больше, чем максимальный
уровень включенного типа, по аналогии с уровнями функций.

То есть новый тип это не что иное как древовидная структура известных типов.
Согласно принятой концепции в языке nic - объект это данные, не содержащие методов,
то любой созданный тип является сигнатурой объекта.

Для обращения к конкретному подтипу данных используется либо имя подтипа, если оно одно
фигурирует в типе, либо индекс типа.

Напримем мы определили тип

INT DUBL STRI 3 newtype NEWT
a1 newtype VAR

для того, чтобы загрузить значение поля DUBL из типа newtype нужно делать так:

a1 DUBL VALU

Слово VALU определяет, что на вершине стека находится тип, который нужно извлечь из переменной
a1. Так как в сигнатуре типа используется только 1 тип DUBL, то VALU легко его найдет,

А что если у нас есть тип с повторяющимися типами, например такой:

INT DUBL DUBL DUBL STRI 5 ntype NEWT
a2 ntyle VAR

В таком случае чтобы добраться до второго DUBL нужно использовать слово IDX

a2 2 IDX DUBL VALU

Конструкция 2 IDX подсказывает VALU что нужно искать второй аргумент с типом DUBL.

А как быть с конструкциями посложнее? Допустим мы создали новый тип, который состоит из 
типов newtype и ntype?

Имеем следующее:

INT DUBL STRI 3 newtype NEWT
INT DUBL DUBL DUBL STRI 5 ntype NEWT
newtype ntype 2 MyType NEWT

Abc MyType VAR

Имеем переменную типа Abc с новым сложным типом. Теперь мы может обратится к любым
возможным полям в этом типе аналогичным обрахом. Допустим мы хотим получить значение третьего
DUBL числа из типа ntype:

Abc ntype 3 IDX DUBL VALU

После этого мы будем иметь результат. С помощью EQUL мы можем проделать обратную процедуру,
для задания значения DUBL

3.1415 Abc ntype 3 IDX DUBL EQUL

Как мы видим, при разворачивании типов записывается сначала сам объект, потом указывается подтип,
потом подтип подтипа и так далее, если подтипов несколько, то указывается индекс подтипа.


На базе таких простых операций как присваивание и чтение значени сложных объектов можно
строить более сложные высокоуровневые слова, которые могут выполнять очень сложные манипуляции
с объектами.


	Для определения массива используется ключевое слово ARRA


10 DIM 1 DUBL AR1 ARRA 				// массив double на 10 элементов

10 DIM 20 DIM 2 DUBL AR3 ARRA  		// double AR3[20][10]

Как видно, для определения размера массива используется DIM.
После всех размеров задается размерность массива и тип, в первом случае это 1
во втором случае 2. Тип обоих массивов DUBL 

Имена массивов AR1 и AR3. 

Или можно например так:
AR1 1 IDX VALU						// Загружаем в стек первый элемент массива
AR3 1 IDX 3 IDX VALU				// Загружаем элемент AR3[3][1]

Это касается определения и доступа к массивам со статическими размерами.
Однако можно создавать массивы и с переменной длиной размерностей.

То есть как можно создать динамический объект, который мог бы получить 
в себя некий другой объект, при этом скопировав бы все свойства копируемого объекта?

Для этого используется слово UDEF (undefined type) 

xx UDEF VAR

Определяет переменную неопределенного типа, к которой может быть присвоен любой объект.
например

10 DIM 20 DIM 2 DUBL AR3 ARRA			// Создаем массив
...										// присваиваем какие-то значения
xx UDEF VAR 							// создаем объект неопределенного типа
EQUL									// Копируем содержимое массива со всем содержимым.

Надо заметить, что EQUL создает копию объекта, и далее xx становится массивом, и он 
живет независимой жизнью от массива AR3.

Если же нам нужно сделать ссылку на существующий объект, еще одно имя синоним для
существующего объекта, то нужно использовать слово MAP:

10 DIM 20 DIM 2 DUBL AR3 ARRA			// Создаем массив
...										// присваиваем какие-то значения
xx UDEF VAR 							// создаем объект неопределенного типа
MAP										// теперь xx это синоним AR3

Как мы видим, можно создавать имена для любых элементов, иметь синонимичные имена
для одних и тех же объектов. Так как все создаваемые структуры и объекты являются глобальными
в пределах запущенного слоя (это неверно для суперслоя и субслоев)
То иногда бывает необходимо создать синоним имени для запуска определенного слова, 
с тем чтобы передать или получить данные из этого слоя по имени.

После того, как имя синоним уже не нужно, его можно удалить используя UMAP (unmap)

xx UMAP
После этого переменная xx больше ни на что не ссылается, и ее можно удалить из переменных
используя DEL.
Следует быть внимательным, нельзя удалять имя-синоним пока оно связано с другим объектом,
так как весь оригинальный объект будет удален вместе с именем-синонимом :).

Если применить слово UDEF для существующей переменной, то все данные, которые она имеют
будут удалены, а динамически выделенная память освобождена.

Одной из особенностей языка nic является то, что можно переименовывать переменные,
если это необходимо:

a1 a2 RENA 
Теперь объекта с именем a1 не существует в системе, вместо его используется имя a2.

Что касается имен переменных, то есть одно правило, что имя переменной может быть любым,
неопределенным в системе словом. Потому что как только интерпретатор встречает новое имя
он создает временную переменную, которая может быть определена или сохранена в системе.

Если же введено какое-то слово, то интерпретатор попытается его выполнить сразу же.
И в зависимости от наличия аргументов получится некий результат.


Как было показано выше, мы можем создавать новые типы (сигнатуры) данных, которые потом
можно использовать для создания объектов. Но ими неудобно пользоваться потому, что
доступ к элеменам осуществляется через индексы (хотя это полезно в циклах).

Для создания объекта, к именам которого можно обратится используем SRTU (structure)

Определение структуры выглядит так:

BYTE A1 VAL INT B1 VAL 2 DDD STRU

Это создаст структуру DDD с двумя полями, которые будут включать в себе два подполя
A1 и B1. Для того, чтобы определить такую струкруту необходимо, чтобы до момента определения
структуры DDD ни переменная A1 и ни переменная B1 не существовали.

После создания структуры, A1 и B1 не будут доступны напрямую из оболочки. Чтобы получить
значение с переменными внутри стукруты нужно использовать следующий синтаксис

DDD A1 VALU
DDD B1 VALU

Если все же переменные A1 или B1 существуют глобально до того, как определяется структура,
ее следует определять несколько иначе

BYTE /A1 VAL INT /B1 VAL 2 DDD STRU

/A1 означает, что подобное имя может существовать, поэтому ставится эскейп последовательность
и в дальнейшем при обращении к имени в структуре тоже нужно ставить эскейп символ /

DDD /A1 VALU
DDD /B1 VALU

Это решает проблему видимости имен. 

Структура может содержать подструктуры и так далее. Принцип построения такой же как и с
вложенными типами. Разыменование и доступ к элементам структуры осуществляется от сложного
к простому.

Используя все вышеописанные методы можно создавать сколь угодно сложные объекты и слова
для их выполнения.



					Циклы
					-----
 	Так как у нас есть периодические структуры типа массивов то разумно иметь возможность
осуществлять циклические повтореня одной или нескольких операций.

Простейшим циклом повторения является конструкция 
DO ... n LOOP
где n - это число повторений цикла.

Эта конструкция может быть многострочной, то есть если в интепретатор вводится DO
то он автоматически входит в режим редактирования до тех пор, пока не вводится завершающее слово
LOOP.

Более того, можно так же делать вложенные циклы, поскольку каждый ввод слова DO увеличивает
счетчик вложенности на 1. Каждое слово LOOP уменьшает счетчик на 1.
Как только счетчик вложенности обнуляется цикл выполняется целиком.

Традиционно в nic используется цикл

DO ... v1 UNTL

Где v1 - это некоторая переменная на вершине стека, значение которой должно
обратится в 0 для того чтобы цикл завершился.

Надо заметить, что переменная v1 может изменяться произвольным образом.
конструкция v1 UNTL помещает значение в стек, сравнивает с 0 и принимает решение
на основе этого что делать дальше.

Этот цикл также следит за вложенностью и как только она обращается в 0 - начинает выполнение 
цикла.

Порой, при написании длинного выражения удобнее перейти на новую строку и при этом отложить
интерпретацию кода до полного ввода выражения.
Для этого используется символ \

Например:
nic(i)> 34 56 ADD \
888 777 MUL \
SUB SHOW

Интерпретация будет отложена до последней строки. Это может быть полезным для ввода не только 
циклов но и логических выражений.

Если вы долго вводили строки и при этом где-то ошиблись, то помимо ilog текстовой переменной
существует еще одна текстовая переменная, которая называется linp (last input)

Ее так же можно загрузить в стек и использовать для повторного запуска, предварительно подправив.
Запустить на интерпретацию содержимое любого текста можно используя слово RUN
Это слово просто извлекает строки по очереди и интерпретирует их.
Ну и естественно может вывалится с ошибкой или предупреждением в процессе.


					Логические выражения
					--------------------

	Так же как и в Си булевых переменных в чистом виде не существует. Любая целочисленная
переменная рассматривается как TRUE если она отлична от нуля. Ну и соответственно 
если она равна 0 то это эквивалентно FALSE.

В связи с этим в языке nic определены глобальные константы TRUE и FALS с соответсвтующим смыслом,
чтобы небыло соблазна переопределять их значение.

Выражение для условных переходов будет записываться так:

cond IF
exp1 ELSE
exp2 THEN

или так

cond IF
exp2 THEN

сond - это логическое условие, на вершине стека, если оно равно 0 то выполняется exp1, если же оно ненулевое, то выполняется
expr2.

Заметим, что так же как и в случае циклов отслеживается вложенность выражений, и конструкция выполняется только тогда
когда вложенность становится равна 0.

При написании логических условий удобно пользоваться символом \ переноса строки.

Оператор множественного выбора (switch) не сущесвтует в языке nic, так как ее легко можно реализовать на основе
конструкции

cond IF
exp2 THEN


	Для постоения логических условий определены стандартные слова с соответствующим смыслом:

AND - логическое И, может применяться ко всем типам, считая их TRUE если они не равны 0. 
OR - или
XOR - исключающее или
NOT - отрицание
EQ - равно
GT - больше
LT - меньше
LE - меньше либо равно
GE - больше либо равно
NE - не равно


Нужно помнить, что в nic как и в Forth не существует скобок поэтому все выражения интерпретируются слева
направо. 

Поэтому выражение будут выглядеть несколько иначе, например

(a == 0 || b <= 3) && (c != 5)

будет записано следующим образом:

0 a EQ 3 b LE OR 5 c NE AND

Иногда бывает нужно пропустить некоторое количество строк или операторов или вернутся назад
тогда можно использовать слова CONT и SKIP

n SKIP - означает, что следует пропустить код до конца цикла и выйти из него. При этом n указывает 
уровень вложенности выхода. Например, если n = 0, то нужно выйти только из самого врутненнего цикла,
Если n = 1, то выйти также и из следующего цикла (если такой существует).

n CONT означает, вернутся к началу цикла, не выходя из него. n - имеет тот же смысл что и в слове SKIP.
Если n = 0, то возвращаться следует к началу самого вложенного цикла, если 1 - то внешнего и т.д.

Эти слова удобно использовать вместе с операторами условного перехода.


						Битовые операции. Символьные преобразования
						-------------------------------------------

	Так как размер стека обычно равен 4 байтам, то для более тонкой работы с данными иногда требуется
манипулировать с отдельными битами.
Это можно сделать с помощью слов BAND (binary and), BOR (binary or), BXOR (binary xor), BNOT (binary not)

Все слова кроме последнего принимают 2 значения, кроме последнего, которому нужен только 1 параметр.

Иногда бывает необходимо получить символьную запись чисел из значений хранящихся в параметрах.
Для этого используются слова NTOA ATON

n f NTOA -> s 
число n преобразуется в строку s по формату f, оно может быть любого числового типа.

s ATON -> s' n
Это слово распознает любое число, разположенное сначала строки, до первого байта не относящегося к числу.
Остаток нераспознанной строки остается в строке s'.

По умолчанию, любое вводимое целое число даже если оно меньше 256 рассматривается как INT. 
Но иногда нужно интерпретировать его как символ, для этого нужно использовать слово ITOB

n ITOB -> b
преобразует число в байт, оставляя самый младший байт и измерянет тип значения в ячейке с INT на BYTE.

По уполчанию даже если использовать PRI, PRIN или SPEL будут печатать BYTE как целое число.

Чтобы превратить BYTE в литерал нужно использовать BTOL - (byte to literal)

Тогда при печати байт будет выглядеть как символ.
Для того, чтобы пользоваться 16 битными символами можно конвертировать ITOC - (int to char)

В этом случае слова PRI, PRIN, SPEL будут выводить 16 битные символы.

С BYTE, CHAR, LETR можно произволить обычные математические операции что и с целыми числами, однако перед выводом
на печать следует убедится, что они имеют правильный тип, так как он может измениться.

Для тонкой манупуляции со стороками используются следующие слова SPLI

s n SPLI -> s' c1 ... cn
Эта операция разбивает первых n символов строки по n ячейкам и помещает остаток строки в s'. Если остатка нет, то 
s' представляет собой пустую строку.

для определения, является ли строка пустой используется слово ISES

s ISES -> n
n = 1 если строка пустая и 0, если нет.

Для обратной операции, если требуется собрать несколько литералов в строку используется слово GLUE

c1 ... cn n GLUE -> s
n - число символов в строке.



						Другие устройства в системе и работа с ними
						-------------------------------------------

 	Как было сказано ранее, оболочка не только занимается интерпретацией кода, но так же позволяет 
обмениваться информацией с внешними устройствами, такими как DISK, UART, NETW, и так далее.

Устройство DISK является единственной точкой входа ко всем жестким дискам, оно аналогично корню файловой
системы.
С любым файлом и каталогом можно производить все обычные операции, READ, WRIT, CREA, FDEL, и тд.
Читать файл можно в любой тип объекта, но при этом они будут заполнятся данными побайтно.
Например, если мы имеем объект некоторого типа, например, содержащий несколько полей INT, 
то при этом в каждую ячейку будут записаны по 8 байт.
Чтение приостановится как только закончится место в структуре.

Если выполнить чтение еще раз, то структура перезапишется сначала и указатель чтения файла двинется дальше.
Так же можно указывать смещение на чтение-запись файла.

Порядок работы с диском следующий.
Сначала создаем переменную типа массив байт

256 DIM 1 BYTE file ARRA
10 offset EQUL

Далее линкуем этот массив с неким файлом на диске. Допустим мы хотим прочитать информацию с файла 

"/tmp/myfile.txt" offset DISK file LINK

Если линк удался, то на вершине стека появляется код операции равный 0. Иначе будут другие коды,
которые можно перевести в строку используя слово DERR, и вывести после этого на печать.
Можно заметить, что как таковой функции открытия или закрытия не существует.

Просто устанавливается связь между 256 байтами, расположенными со смещения 10 в файле и 256 байтами
массива.

Никакого переноса данных ни в каком направлении не происходит.
Для того чтобы выполнить реальную операцию, нужно сделать операцию

file SYNC
эта операция так же оставляет код операции на вершине стека, которую можно интерпретировать DERR.

Если мы модифицировали данные в массиве и хотим сохранить его на диск мы должны вызвать 

file SAVE
Который так же оставляет код операции в стеке после выполнения.

Как же нам считать весь файл?
Очень просто, для этого мы должны слинковать этот же массив с другим местом файла, например так:

266 offset EQUL
"/tmp/myfile.txt" offset DISK file LINK
file SYNC
2 DROP				// мы удалили 2 ячейки с кодом операций, чего обычно делать не следует.

заметим, что нет необходимости закрывать файл, для смещения по некому адресу.
После работы с массивом опять делаем 
file SAVE

и можем отключить наш массив от диска
file ULIN

После этого, любые операции с массивом данных не будут ничего менять на диске.

Нужно заметить, что операции LINK/ULIN работают универсальным образом для всех типов объектов
Они включают побайтовое отображение одного объекта на другой. Об этом более подробно в следующем разделе.

Один и тот же файл может быть слинкован с разными массивами(и не только массивами) данных, если для этого есть
разрешение в системе. Более того, разные процессы могут иметь доступ к таким вот файлам и использовать их
для передачи данных из одного процесса в другой процесс.

Синхронизация передачи данных это задача программиста, оболочка лишь позволяет использовать обращение
к файлам таким образом.

Аналогичным образом производится работа с UART, посредством открытия канала, организацией буфера,

Потом линковка с массивом данных. Так как поступление данных асинхронно во времени, то входной буфер может переполнятся
если в него пришло слишком много информации. С этой целью, для чтения из UART или NETW устройств
лучше запускать отдельные подпроцессы, которые будут ждать приема данных на этих устройствах и 
копировать их в бОльший буфер или обрабатывать.


256 DIM 1 BYTE uart0 ARRA

0 UART uart0 LINK		// Ноль означает номер уарта, в случае если у системы несколько портов.
uart0 SYNC

Операция синхронизации приведет к ожиданию до тех пор пока не поступит хотя бы 1 байт на вход устройства.
Для того, чтобы этого не происходило можно установить таймаут для операции синхронизации для порта

50 0 UART TOUT			// 50 милисекунд таймаут. После этого операция SYNC завершается и идет дальше.

Операция SYNC помещает в стек количество прочитанных байт в массиве.
Для посылки данных в порт может использоваться тот же массив байт, либо другой буфер, слинкованный с 
портом, например

256 DIM 1 BYTE sendbuf ARRA
0 offset EQUL
20 len EQUL

0 UART sendbuf LINK			// Ноль означает номер уарта, в случае если у системы несколько портов.
offset len sendbuf SAVE		// Посылает 20 байт в порт UART 0

Все операции работы с асинхронными устройствами оставлят код завершения в стеке, который можно поверить.

для освобождения порта нужно выполнить операцию ULIN.

uart0 ULIN
sendbuf ULIN
2 DROP

Для конфигурации устройств или для определения их параметров используется ряд слов, например, как уже
было показано выше слово TOUT задает таймаут для устройства,
ее же можно использовать для получения текущего таймаута в устройстве,

например используя команду

-1 0 UART TOUT		// -1 означает невалидный параметр, при этом в стеке появятся 2 значения, текущее
					// значение таймаута и код завершения.

Еще одно слово которое утанавливает параметры скорости порта например BRAT (bitrate), PARI (parity), SBIT
и ряд других.
Принцип получения данных из устройства такой же как и у UART.

Получить список возможных команд у интерпретатора можно используя команду 
HELP UART

Для диска 
HELP DISK 

для NETW
HELP NETW 

Если иногда возникает необходимость сделать задержку выполнения, для этого нужно использовать WAIT

200 WAIT
приводит к приостановке выполнения на 200 милисекунд.



						Отображения сложных структур данных, линковка каналов
						-----------------------------------------------------   

	Как я уже упоминал выше, у оболочки есть 4 специальных устройства, с помощью
которых можно организовывать многопоточное приложение или систему взаимодействующих процессов.
Эти устройства называются TOP, BOT(боттом), GIVE, TAKE.

Рассмотрим подробнее уровни и взаимозависимости процессов.

Каждая оболочка (интерпретатор) запускает только 1 поток выполнения, который может прерываться 
вводом с термнала. Однако для создания более сложных приложений необходимо запускать
асинхронно другие параллельные процессы.

	Все процессы в языке nic не независимые, а подченены иерархически. Из запущенной оболочки
можно запустить только субпроцессы. Запущенный субпроцесс не может иметь те же привелегии, что
и начальный процесс, он всегда будет управлятся. Если такое управление теряется, то субпроцесс
умирает через некоторое время. Время через которое субпроцесс уничтожается конфигурируется
при запуске. Это время представляет собой максимальное время через которое может придти
сигнал или объект от родителя. Если сигнал не приходит, то субпроцесс посылает всем своим
субсубпроцессам сигнал на завершение процесса и сам завершается.
Время ожидания сигнала не может быть бесконечным, то есть субпроцесс завершается всегда
через какое-то время если предок умирает.

В этом состоит отличие от концепции в юникс, в котором при завершении предка все дочерние
процессы получают нового родителя и продолжают выполнение.

Все процессы в системе имеют одинаковые слова нулевого уровня. Более того, все загруженные
слова в процессе выполнения также доступны для субпроцессов.
Субпроцессы так же знают о созданных типах и распознают сигнатуры типов.
Однако данные в субпроцессах никак не связаны с данными родителя по умолчанию.
Тем не менее, процесс и субпроцессы могут легко обмениваться данными (объектами).

Каждый запущенный субпроцесс имеет номер, для запуска субпроцесса нужно выполнить команду

1 pid EQUL			// Любое произвольное целое число, кроме нуля.
wrd pid BOT RUN 	// Запускаем слово wrd с номером субпроцесса pid.

Для передачи какого либо объекта субпроцессу нужно использовать слово SAVE

например

Obj pid BOT SAVE			// Передаем объект Obj субпроцессу.

Этот объект субпроцесс может синхронизировать с любым объектом на своем уровне. Для этого нужен
следующий код

o1 TOP SYNC			// o1 - это некий объект, куда будет сериализоваться данные поступившие сверху.

Как было сказано выше, сигнатуры типов процесса так же известны и субпроцессам, поэтому для правильной
сериализации желательно использовать объекты одинакового типа, хотя это и не обязательно.

Если процесс хочет послать сообшение сразу всем субпроцессам, для этого нужно использовать 0 на месте идентификатора
процессов.

0 broadcast EQUL
obj broadcast BOT SAVE

Операция SAVE выполняется без задержек, но вот операция SYNC как обычно выполняется с некоторым заданным
таймаутом. 

Причем родительский процесс может менять время таймаута для операции SYNC 
для чтения данных от субпроцессов, а субпроцессы не могут менять таймаут самостоятельно.

Только родитель может задать это время для подчиненного процесса.

50 pid BOT TOUT			// Устанавливаем время таймаута для операции SYNC при чтении данных
						// от субпроцесса pid.

50 tout EQUL
tout TOUT pid BOT SAVE 	// так устанавливается время таймаута SYNC для субпроцесса pid

Субпроцесс также может посылать данные родительскому процессу через канал TOP и он у каждого 
процесса только один.

data mytype VAR
...						// Задаем данные для data
data TOP SAVE			// передаем данные предку, если он существует.

В случае, если субпроцесс теряет канал данных от родителя, то операция SYNC возвращает код ошибки
"родителя не существует", и этот процесс обязан также завершится.

То есть Каждый процесс может создавать некоторую совокупность процессов, причем разворачиваются
они как дерево, и потом уничтжаются в обратной последовательности, либо целиком, как дерево.

Иногда можно создавать самостоятельные процессы и пытаться подключится к сущесвтующим
процессам в качестве ведомого.

Для этого нужно, чтобы ведущий процесс периодически опрашивал BOT на предмет подключения
некого субпроцесса.

Это может оказаться полезным для взаимодействия с программами, написанными на других языках
программирования, например на си, и которые взаимодействуют с аппаратным обеспечением
системы (драйверы спецустройств).

При этом взаимодействие будет осуществляться через диск (tmpfs) в памяти компьютера.

Подчиненный процесс может получать данные в свои структуры данных и затем отправлять эти данные
назад вверх.


	У каждого процесса есть горизонтальный уровень процесса. Чем старше процесс (ближе к корню процессов), 
тем меньше этот номер для самого первого процесса в системе это уровень равен нулю.
Субпроцесс первого процесса в системе будет иметь горизонтальный номер 1, субсубпроцесс номер слоя 2 и т.д.

Процессы находящиеся на одном слое могут взаимодействовать горизонтально через каналы GIVE и TAKE.

	GIVE отсылает данные в общий пул, который могут считать другие процессы командой TAKE.
Этот буфер не бесконечный, и если никто не читает сообщения, то они пропадут, так как каждый
канал имеет ограниченный буфер, если он не расширен специально.

Для оправки и изымания данных используются слова SAVE и SYNC, при этом посылка происходит 
в некий почтовый ящик. 

Чтобы начать взаимодействие в горизонтальном слое каждый процесс открывает свой почтовый ящик и регистрирует его
в слое.
для этого нужно сделать

256 DIM 1 BYTE ar1 ARRA		// Массив 256 байт
10 boxid EQUL				// номер ящика на отправку сообщения.

boxid GIVE ar1 LINK			// Регистрируем почтовый ящик для отправления сообщейния размером 256 байт

Аналогично можно связать буферы с любым из существующих в слое ящиках.
Для этого можно получить номера открытых ящиков в слое

например


256 DIM 1 INT boxIDs ARRA	// Массив для индексов
0 TAKE boxIDs SYNC			// запрашиваем у 0 почтового ящика список всех зарегистрированных ящиков

После этого можно делать LINK на любой зарегистрированный ящик в слое и читать из него
данные стандартным образом с помощью SYNC.

Заметим, что мы должны создавать буфер для отправки сообщения, связанный с неким локальным объектом,
и его можно менять в программе сколько угодно раз, но чтобы изменить его во внешнем почтовом 
ящике нужно изпользовать SAVE.

После завершения работы с внешиним почтовым ящиком его можно отсоединить словом ULIN.

Как видно из описания, передача данных в слое полностью аналогична работе с UART.


						Внутренняя база данных оболочки
						-------------------------------

	Если произвести выход из интерпретатора по команде EXIT то все созданные или загруженные объекты в системе 
выгрузятся автоматически. Для того, чтобы полностью восстановить состояние переменных, загруженных типов
или созданных слов в оболочке существует специальное устройство DATA, которая может хранить 
всю информацию о текущем состоянии системы.

Для этого нужно сделать операцию
0 DATA SAVE			// coхранить все данные в базе данных оболочки

И чтобы восстановить данную точку сохранения нужно сделать обратную операцию

0 DATA SYNC			// Восстановить все данные из базы данных в интерпретаторе

При этом все объекты существующие в базе данных будут загружены в оболочку и будут восстановлены из базы данных.

Можно также сохранять и восстанавливать данные по конкретным переменным, но при этом нужно помнить, что переменные
восстановленные из DATA могут изменить состояние переменных с аналогичными именами в системе.

Так же возможна и более гибкая работа с устройством DATA.